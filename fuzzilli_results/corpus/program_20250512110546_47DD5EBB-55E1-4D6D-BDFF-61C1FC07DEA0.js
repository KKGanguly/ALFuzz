const v1 = new WeakSet();
let v3 = 6n;
const v4 = v3--;
v4 * v4;
const v6 = v4 != v4;
16n ^ 16n;
function f9() {
    return v3;
}
try { Set(); } catch (e) {}
const v12 = new Set();
class C13 {
    [WeakSet];
    static #a;
    set e(a15) {
        for (let v16 = 0; v16 < 10; v16++) {
            v1["p" + v16] = v16;
        }
        const v19 = v12[268435440];
        try { v19.trim(v19, v19, 16n, v19, v19); } catch (e) {}
    }
    [v3] = v12;
    static #e = v12;
}
try { C13.toString(); } catch (e) {}
const v22 = new C13();
v22[6] = v22;
new C13();
const v24 = new C13();
const v25 = v24[6];
v25 ?? v25;
v25 ?? v25;
WeakMap.name;
const v30 = new WeakMap();
try { v30.has(v6); } catch (e) {}
let v32;
try { v32 = v30.delete(v30); } catch (e) {}
v32 && v32;
const v34 = v30?.constructor;
let v35;
try { v35 = new v34(); } catch (e) {}
let v36;
try { v36 = v35.delete(9007199254740991n); } catch (e) {}
v36 || v36;
const v39 = new Error(Error);
v39.message = v39;
const v40 = v39?.constructor;
v40.stackTraceLimit;
v40.prototype = v40;
let v42;
try { v42 = new v40(v22); } catch (e) {}
v42.message = v42;
const v43 = v42?.constructor;
let v44;
try { v44 = new v43(v25); } catch (e) {}
v44.stack;
Set >>>= Set;
const v47 = new C13(Set, Set, C13, ..."stack");
let v48;
try { v48 = v47.isPrototypeOf(v24); } catch (e) {}
v48 && v48;
let v50;
try { v50 = f9(v30, v30, ..."stack", ...v22); } catch (e) {}
~(v50 >>> v50);
v50 ?? v50;
0.098614826663601 + 0.098614826663601;
let v56 = 1.3925568650729292e+308;
v56++;
0.17003107954404972 << 0.17003107954404972;
