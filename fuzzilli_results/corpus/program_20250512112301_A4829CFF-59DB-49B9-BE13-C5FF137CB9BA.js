const v2 = new Uint32Array(129);
let v3 = 124;
-v3;
const v5 = v3--;
v5 ^ v5;
Int16Array.g = Int16Array;
let v8;
try { v8 = Int16Array.bind(129); } catch (e) {}
try { v8(v2, v2, v8); } catch (e) {}
const v10 = new Int16Array(v3);
let v11 = 201;
const v12 = v11 | v11;
const v13 = v11++;
v13 != v13;
let v16;
try { v16 = Int32Array.call(129); } catch (e) {}
v16 ?? v16;
v16 ?? v16;
const v19 = new Int32Array(v11);
try { v19.join(v11); } catch (e) {}
try { v19.find(v19); } catch (e) {}
class C22 {
    p(a24, a25) {
        delete this[v19];
        this[65536] = a24;
        for (let v27 = 0; v27 < 37; v27++) {
            const v28 = 129 ^ v27;
            function F29(a31, a32, a33) {
                if (!new.target) { throw 'must be called with new'; }
                this.e = a32;
                this.c = a31;
            }
            const v34 = new F29(v11, 129, v10);
            const v35 = new F29(v28, 129, v34);
            new F29(v28, v3, v35);
        }
        return 129;
    }
}
try { new C22(); } catch (e) {}
~(-C22.length);
const v41 = new C22();
v41.__proto__;
new C22();
new C22();
class C45 extends Uint32Array {
    static h = v2;
    #valueOf(a47, a48, a49, a50) {
        try {
            new Int16Array(C22);
        } catch(e52) {
        }
        return a49;
    }
    p(a54, a55) {
        a54[44];
        let v58 = -7820;
        v58 >>> v58;
        ++a55;
        const v61 = C22 ** C22;
        Math.log(v61);
        !v58;
        !(!v58);
        const v66 = Math.max(v61);
        v66 >> v66;
        let v68 = --v58;
        v68++;
        return Uint32Array;
    }
}
let v70;
try { v70 = new C45(); } catch (e) {}
try { v70.p(v2, v16); } catch (e) {}
new C45();
const v73 = new C45();
v73.BYTES_PER_ELEMENT = v73;
let v74;
try { v74 = v73.fill(Uint32Array); } catch (e) {}
try { v74.reverse(); } catch (e) {}
let v76;
try { v76 = v74.reverse(); } catch (e) {}
try { v76.sort(v73); } catch (e) {}
const v78 = new C45();
try { v78.some(v16); } catch (e) {}
function f80(a81, a82) {
    a81.message = a81;
    return a82;
}
Error.prepareStackTrace = f80;
try {
    throw Error(/(invalid regexp)/);
} catch(e86) {
    const v87 = e86?.toString;
    let v88;
    try { v88 = new v87(); } catch (e) {}
    v88 ?? v88;
    const v90 = e86.stack;
    try { v90.copyWithin(v73, v12); } catch (e) {}
    const v92 = v90[0];
    const v93 = v92?.isNative;
    try { new v93(); } catch (e) {}
    try { v92.toString(); } catch (e) {}
    let v96;
    try { v96 = v92.getMethodName(); } catch (e) {}
    v96 ?? v96;
    const v98 = v92.getThis();
    const v99 = v98?.SharedArrayBuffer;
    try { v99.call(v99); } catch (e) {}
    let v101;
    try { v101 = new v99(v11); } catch (e) {}
    v101.e = v101;
    const v102 = v98.toString(v98, v92);
    try { v102.matchAll(v92); } catch (e) {}
    try { v102.isWellFormed(); } catch (e) {}
    let v105;
    try { v105 = v102.toLocaleUpperCase(); } catch (e) {}
    try { v105.codePointAt(v12); } catch (e) {}
}
