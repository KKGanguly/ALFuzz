const v0 = [];
const v1 = [v0,v0];
const v2 = [v1,v1,v1,v0,v1];
const v3 = [v2,v2,v2];
function f4() {
    return v0;
}
function f8(a9, a10, a11, a12) {
    return "o";
}
f8(v1, v1, f8, v0);
Object.defineProperty(v0, "length", { writable: false });
f8(v0, f8, f4, v3);
const v20 = f8(v3, "o", "o", v3);
const v21 = [-7,2,744383821,-61538,2147483647,-915060715,268435440,4,13579];
[55345,1819500643,65536,1073741824,1000];
const v23 = [-1024,9,-2];
for (let i25 = (() => {
        function f24() {
            return f24;
        }
        return f24;
    })();
    !i25;
    ) {
}
function f29(a30, a31) {
    return a31;
}
Error.prepareStackTrace = f29;
try {
    throw Error(/(invalid regexp)/);
} catch(e35) {
    const v37 = e35.stack[0];
    const v38 = v37.getThis();
    v38.toString(v38, v37);
}
for (let i41 = 0; i41 < 1000000; i41++) {
}
if (false) {
    v23["findLast"](Error, v21);
} else {
    try { ("length").endsWith("g", "g"); } catch (e) {}
}
const v53 = ["invalid"];
for (let i55 = 0; i55 < v53.length; i55++) {
    try {
        const v61 = v53[i55];
        Error.prototype.toString.call(v61);
    } catch(e65) {
    }
}
const v66 = [];
Reflect.apply(v2.values, v1, v66);
const v71 = v0 - v2;
v0 + v0;
v20 & v71;
v20 || 1000000000.0;
Math.min(1000000000.0);
v2 * v20;
v20 ?? 1000000000.0;
